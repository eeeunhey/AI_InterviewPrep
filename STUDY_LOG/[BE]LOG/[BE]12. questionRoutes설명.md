순서
1. server.js app.use('api/question', questionRoutes); 입력
2. routes/questionRoutes.js controller 기능 호출
3. questioncontroller.js


1. questioncontroller.js_addQuestionsToSession 
기존 세션(Session)에 질문들을 추가하는 API 컨트롤러

🔎 코드 해석
exports.addQuestionsToSession = async (req, res) => {
  try {
    const { sessionId, questions } = req.body;


클라이언트가 보낸 JSON Body에서 sessionId와 questions를 꺼냅니다.
sessionId: 질문을 추가할 세션의 ID

questions: [{ question: "...", answer: "..." }, ...] 형태의 배열

    if (!sessionId || !questions || !Array.isArray(questions)) {
      return res.status(400).json({ message: "invalid input data" });
    }


유효성 검사
sessionId가 없거나
questions가 비어있거나
questions가 배열이 아닐 경우

잘못된 요청으로 보고 400 Bad Request 반환
    const session = await Session.findById(sessionId);

    if (!session) {
      return res.status(404).json({ message: "Session not found" });
    }


MongoDB에서 해당 sessionId를 가진 세션이 실제로 존재하는지 확인
없으면 404 Not Found 반환

    // 새로운 질문 생성을 위한 코드블럭
    const createQuestions = await Question.insertMany(
      questions.map((q) => ({
        session: sessionId,
        question: q.question,
        answer: q.answer,
      }))
    );


questions 배열을 순회하면서 각 질문을 Question 문서로 생성
session: sessionId → 어떤 세션에 속한 질문인지 연결
question, answer → 질문 내용과 답변 저장
insertMany → 여러 문서를 한 번에 DB에 저장
결과(createQuestions)는 실제로 DB에 추가된 질문들의 배열

  } catch (error) {
    res.status(500).json({ message: "Server Error" });
  }
};


실행 중 에러 발생 시 500 Internal Server Error 반환

✅ 현재 코드 문제
createQuestions를 만들어 놓았지만 응답으로 내려주지 않음 → 프론트엔드에서 추가된 질문을 확인할 수 없음
보통은 아래처럼 응답을 내려주는 게 맞습니다:
res.status(201).json({
  success: true,
  addedQuestions: createQuestions,
});

📌 정리

이 함수는:
클라이언트에서 sessionId와 questions를 입력받고
세션이 유효한지 확인한 뒤
여러 질문을 한꺼번에 DB에 저장하는 로직

---


1️⃣ togglePinQuestion (질문 고정/해제)
// @desc 질문을 고정하거나 고정을 해제한다
// @route POST /api/questions/:id/pin
// @access Private
exports.togglePinQuestion = async (req, res) => {
    try{
      const question = await Question.findById(req.params.id);

      if (!question) {
        return res
          .status(404)
          .json({ success: false, message: "질문을 찾을 수 없습니다" });
      }
    
      // 현재 값 반전 (true → false, false → true)
      question.isPinned = !question.isPinned;
      await question.save();

      res.status(200).json({ success: true, question });
    } catch (error) {
        res.status(500).json({ message: "Server Error" });
    }
};

동작 원리

질문 찾기: req.params.id(URL 파라미터로 받은 질문 ID)를 이용해 DB에서 질문을 찾음.
없는 경우: 해당 질문이 없으면 404 에러와 함께 "질문을 찾을 수 없습니다" 메시지 반환.
있는 경우: isPinned 값을 반대로 토글 (고정 ↔ 해제).
예: false → true, true → false
DB 저장: 변경된 값을 question.save()로 저장.
응답: 성공적으로 처리되면 200 OK와 함께 업데이트된 질문 객체 반환.
👉 즉, 질문을 한 번 누르면 고정, 다시 누르면 해제하는 기능.



2️⃣ updateQuestionNote (질문 노트 수정)
// @desc 질문에 대한 노트를 수정한다
// @route POST /api/questions/:id/note
// @access Private
exports.updateQuestionNote = async (req, res) => {
    try{
        const { note } = req.body;
        const question = await Question.findById(req.params.id);

        if(!question) {
            return res
              .status(404)
              .json({ success: false, message: "Question not found" });
        }

        // note가 없으면 빈 문자열로 초기화
        question.note = note || "";
        await question.save();

        res.status(200).json({ success: true, question });
    } catch (error) {
        res.status(500).json({ message: "Server Error" });
    }
};

동작 원리

note 추출: req.body에서 노트 내용을 가져옴.
질문 찾기: 마찬가지로 req.params.id를 이용해 DB에서 질문 검색.
없는 경우: 질문이 없으면 404 에러와 "Question not found" 반환.
있는 경우: question.note 필드에 새로운 note 값 저장.
만약 값이 없으면(undefined/null) 빈 문자열("")로 저장.
DB 저장: question.save()로 DB에 업데이트.
응답: 성공하면 200 OK와 함께 업데이트된 질문 객체 반환.
👉 즉, 특정 질문에 대해 메모/설명을 덧붙이거나 수정하는 기능.


🔑 요약
togglePinQuestion: 질문의 고정 여부(isPinned)를 토글하는 API.
updateQuestionNote: 특정 질문에 메모(note)를 작성/수정하는 API.
두 API 모두 URL에서 질문 ID를 받아 DB에서 해당 질문을 찾고, 없다면 404 반환.
성공 시 수정된 질문을 그대로 반환하므로, 프론트엔드에서 즉시 반영 가능.