250906 트러블 슈팅
1. 로그인 후 이미지 뜨지 않음
    backend/uploads 에 사진파일이 올라가지도 않음

- 그래서 json_test 해봄
    http://localhost:8000/api/auth/image-upload
    (form-data) post : img 보내봄 
    uploads 파일에 잘 들어갔다
    그래서 
    GET http://localhost:8000/uploads/1757158903602-Profile01.jpg
    이것도 잘 가져왔다 200 OK
        {
        "imageUrl": "http://localhost:8000/uploads/1757158903602-Profile01.jpg"
        }

    그래서 FE가 문제구나 하면서 gpt 선생님과 많은 대화를 했으나 
    문제는 user.profileImageUrl 값이 아직 없는데 그대로 <img src>에 넣어서 src=""가 된 거예요.
    해결은 간단히, 값이 없을 땐 기본 이미지나 null을 넣도록 조건부 처리(user?.profileImageUrl || "/default.png")만 추가하면 됩니다.
    이런 이상한 소리만 반복했다... 그래서 코드를 계속 수정했다 
    아오... 정말 짜증이난다
    근데 아무리 생각을 해봐도 그게 아닌거 같아서 다시 코드를 뜯어봤다
    upload가 안되고 있는거 같았다 그래서 uploadImage코드가 잘 적혀있었다 그래서 의심을 안했다
    utils/uploadImage 
    근데 왠걸.. 아 정말 import 를 안했던 것이었다 ... 
    설마 했는데 맞았다... 

2. 로그인 후 dashboard 이동 시 src={user.profileImageUrl} null 값이 들어감
분면 로그인을 했는데 왜 null이 들어갈까
그래서 화면 렌더링이 안된다 

비동기 타이밍
로그인/프로필 가져오기 = 비동기 네트워크 요청
React 상태 업데이트 = 비동기적으로 스케줄링되어 다음 렌더에서 반영됨
그래서 “대시보드가 먼저 렌더되고, user는 나중에 준비됨”이라는 시간차가 발생

  updateUser(data.user); 업데이트 후
  navigate("/dashboard"); dashboard 렌더하라고 수정
  그 뒤에는 화면에 잘 출력된다

updateUser(data.user)를 안 할 때
현재 실행 중인 앱에는 아직 user 상태가 없음.
하지만 localStorage에 토큰은 저장돼 있으니, 다음번 앱 초기화(useEffect) 시점에 토큰을 꺼내 /api/auth/profile 같은 API를 호출해서 user를 다시 채움





 **비동기 코드 짤 때 꼭 신경 써야 하는 핵심 패턴**

---

## 1) **가드(Guard)**

> "데이터가 아직 없을 수 있다"는 걸 대비해서 **안전망**을 깔아둬라

* **왜 필요해?**
  서버에서 데이터를 가져오기 전에 컴포넌트는 이미 렌더링돼요.
  이때 `user.name`처럼 바로 접근하면 `Cannot read properties of undefined` 에러가 터집니다.

* **어떻게?**
  * `loading` 상태일 때는 UI 대신 스켈레톤이나 로딩 화면을 보여줍니다.
  * 데이터 접근 시 `옵셔널 체이닝(?.)` 과 기본값(`??`)을 사용합니다.

```jsx
if (loading) return <p>불러오는 중...</p>;
<p>{user?.name ?? "손님"}</p>
```

---

## 2) **정리(Cleanup)**

> “나간 컴포넌트가 불필요하게 동작하지 않도록 뒷정리를 해라”

* **왜 필요해?**
  예를 들어 프로필 이미지를 Blob URL로 미리보기하면 메모리를 계속 차지합니다.
  또, 컴포넌트가 언마운트 됐는데도 `setState`를 호출하면 경고/버그가 납니다.

* **어떻게?**

  * `useEffect`에서 `return () => { ... }` 안에 정리 코드 작성
  * Blob URL은 `URL.revokeObjectURL()`로 해제
  * 네트워크 요청은 `AbortController`로 취소

```jsx
useEffect(() => {
  const url = URL.createObjectURL(file);
  setPreview(url);
  return () => URL.revokeObjectURL(url); // 정리
}, [file]);
```

---

## 3) **순서(Ordering)**

> **필요한 작업은 반드시 순차적으로 await** 해서 순서 보장하기

* **왜 필요해?**
  로그인 → 토큰 저장 → 프로필 불러오기 → 대시보드 이동
  순서를 보장하지 않으면, 프로필이 오기 전에 대시보드로 가서 `user`가 null일 수 있습니다.

* **어떻게?**

  * `await`로 반드시 앞 작업이 끝난 뒤 다음 작업 실행
  * “성공해야 다음 단계로 넘어감”을 명확히

```js
const { data } = await axios.post("/api/auth/login", body);
localStorage.setItem("token", data.token);

const me = await axiosInstance.get("/api/auth/profile"); // 토큰 필요
updateUser(me.data);

navigate("/dashboard"); // 마지막에 이동
```

---

## 4) **경쟁(Race condition)**

> 동시에 여러 요청이 있을 때, **마지막 요청만 반영**하거나 **취소**하라

* **왜 필요해?**
  검색창 자동완성처럼 사용자가 빠르게 입력하면
  먼저 보낸 요청이 늦게 도착해서 최신 결과를 덮어버릴 수 있습니다.

* **어떻게?**

  * 요청마다 ID를 두고, 가장 마지막 요청만 반영
  * `AbortController`로 이전 요청 취소

```js
let reqId = 0;
async function search(query) {
  const id = ++reqId;
  const res = await axios.get("/search", { params: { q: query } });
  if (id !== reqId) return; // 오래된 요청이면 무시
  setResults(res.data);
}
```

---

## 5) **토큰(Token)**

> 토큰은 항상 **실시간으로 읽어와** 요청할 때 붙여라

* **왜 필요해?**
  토큰을 state에만 두면, 토큰이 바뀌었는데 axios가 예전 토큰을 계속 보낼 수 있습니다.

* **어떻게?**

  * axios 인터셉터에서 **요청 직전** `localStorage.getItem("token")`으로 읽음
  * 항상 최신 토큰이 붙습니다.

```js
axiosInstance.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});
```

---

## 6) **UX (사용자 경험)**

> 네트워크는 불안정하다. 사용자가 **안정감을 느끼도록** 배려하라

* **왜 필요해?**

  * 느리면 사용자 입장에선 “버튼 눌렀는데 아무 반응 없음”이라고 느낍니다.
  * 중복 클릭하면 같은 요청이 여러 번 날아갈 수 있음.
  * 서버 에러가 나면 이유를 알려줘야 사용자도 재시도합니다.

* **어떻게?**

  * 로딩 중엔 버튼을 비활성화하거나 스피너 표시
  * 요청 실패 시 메시지 표시 + 재시도 버튼
  * 같은 요청을 연타하지 못하게 `submitting` 플래그 두기

```jsx
<button disabled={loading}>
  {loading ? "로그인 중..." : "로그인"}
</button>
{error && <p className="text-red-500">{error}</p>}
```

---

## 📌 정리

* **가드** → 데이터 없을 수 있다. 안전망 깔자.
* **정리** → 사용 끝난 리소스/요청은 꼭 해제하자.
* **순서** → 중요한 흐름은 `await`로 보장하자.
* **경쟁** → 오래된 응답이 최신 데이터를 덮지 않게 하자.
* **토큰** → 항상 최신 토큰을 읽어서 붙이자.
* **UX** → 로딩, 에러, 중복 제출을 신경써서 사용자에게 안정감을 주자.

---

## http://localhost:8000/api/ai/generate-questions
API 호출 에러발생
- { "message": "질문 생성에 실패하였습니다."
    , "error": "{\"error\":{\"code\":400,\"message\":\"* 
    GenerateContentRequest.model: unexpected model name 
    format\\n\",\"status\":\"INVALID_ARGUMENT\"}
  }"

1. SDK랑 문법 수정

@google/genai

생성자 new GoogleGenAI({ apiKey })
호출 ai.models.generateContent({ model, contents })
응답 response.text (프로퍼티)
모델명 포맷 준수: gemini-2.5-flash-lite (소문자+하이픈)
